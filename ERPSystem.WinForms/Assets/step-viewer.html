
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body, #viewport { margin:0; padding:0; width:100%; height:100%; background:#f8fafc; overflow:hidden; }
  </style>
</head>
<body>
  <div id="viewport"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/occt-import-js@0.0.23/dist/occt-import-js.js"></script>
  <script>
    window.__stepViewerReady = false;
    window.__stepViewerVersion = '0.0.0';
    window.__stepViewerStatus = { ready:false, phase:'boot', error:null, version:'dev' };

    window.onerror = function(message, source, lineno, colno, error) {
      const details = `${message || 'window-error'} @ ${source || 'unknown'}:${lineno || 0}:${colno || 0}`;
      window.__stepViewerStatus.phase = 'error';
      window.__stepViewerStatus.error = `${details}${error && error.stack ? `\n${error.stack}` : ''}`;
      console.error('[viewer.onerror]', window.__stepViewerStatus.error);
    };

    window.onunhandledrejection = function(event) {
      const reason = event && event.reason ? String(event.reason?.stack || event.reason?.message || event.reason) : 'unhandled rejection';
      window.__stepViewerStatus.phase = 'error';
      window.__stepViewerStatus.error = reason;
      console.error('[viewer.onunhandledrejection]', reason);
    };
    const viewport = document.getElementById('viewport');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#f8fafc');

    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 5000);
    camera.position.set(1.2, 0.9, 1.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    viewport.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.target.set(0, 0, 0);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x6f7a88, 0.95));
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.75);
    keyLight.position.set(3, 6, 5);
    scene.add(keyLight);

    let activeMeshRoot = null;
    let occtModulePromise = null;

    function base64ToUint8Array(base64) {
      const raw = atob(base64);
      const bytes = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; i++) {
        bytes[i] = raw.charCodeAt(i);
      }
      return bytes;
    }

    function result(ok, stage, error, stack, parser, meshCount, triangleCount) {
      return { ok, stage, error: error || '', stack: stack || '', parser: parser || '(none)', meshCount: meshCount || 0, triangleCount: triangleCount || 0 };
    }

    function clearScene() {
      if (!activeMeshRoot) {
        return;
      }

      scene.remove(activeMeshRoot);
      activeMeshRoot.traverse(node => {
        if (node.geometry) {
          node.geometry.dispose();
        }

        if (node.material) {
          if (Array.isArray(node.material)) {
            node.material.forEach(material => material.dispose());
          } else {
            node.material.dispose();
          }
        }
      });

      activeMeshRoot = null;
    }

    async function getOcctModule() {
      if (!occtModulePromise) {
        occtModulePromise = occtimportjs({
          locateFile(path) {
            return `https://cdn.jsdelivr.net/npm/occt-import-js@0.0.23/dist/${path}`;
          }
        });
      }

      return occtModulePromise;
    }

    function decodeStepText(bytes) {
      try {
        const decoded = new TextDecoder('utf-8', { fatal: false }).decode(bytes);
        return decoded || '';
      } catch {
        return '';
      }
    }

    function validateStepContent(bytes) {
      const sample = decodeStepText(bytes.subarray(0, Math.min(bytes.length, 8192))).toUpperCase();
      if (!sample.includes('ISO-10303-21') && !sample.includes('ISO10303-21')) {
        return result(false, 'validate-bytes', 'invalid-step-header');
      }

      if (!sample.includes('HEADER;') || !sample.includes('DATA;')) {
        return result(false, 'validate-bytes', 'invalid-step-body');
      }

      return result(true, 'validate-bytes', '');
    }

    function fitCameraToObject(object3D) {
      const box = new THREE.Box3().setFromObject(object3D);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z, 0.001);
      const distance = maxDim * 2.4;

      controls.target.copy(center);
      camera.position.set(center.x + distance, center.y + distance * 0.7, center.z + distance);
      camera.near = Math.max(maxDim / 1000, 0.001);
      camera.far = Math.max(maxDim * 200, 500);
      camera.updateProjectionMatrix();
      controls.update();
    }

    function buildMeshGroup(resultData) {
      const group = new THREE.Group();
      let triangleCount = 0;

      for (const meshData of resultData.meshes || []) {
        const attrs = meshData.attributes || {};
        const positions = attrs.position && attrs.position.array ? attrs.position.array : null;
        if (!positions || positions.length === 0) {
          continue;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        if (attrs.normal && attrs.normal.array && attrs.normal.array.length > 0) {
          geometry.setAttribute('normal', new THREE.Float32BufferAttribute(attrs.normal.array, 3));
        } else {
          geometry.computeVertexNormals();
        }

        if (meshData.index && meshData.index.array && meshData.index.array.length > 0) {
          geometry.setIndex(meshData.index.array);
          triangleCount += Math.floor(meshData.index.array.length / 3);
        } else {
          triangleCount += Math.floor(positions.length / 9);
        }

        const color = (meshData.color && meshData.color.length >= 3)
          ? new THREE.Color(meshData.color[0], meshData.color[1], meshData.color[2])
          : new THREE.Color('#4a78bb');

        const material = new THREE.MeshStandardMaterial({
          color,
          roughness: 0.55,
          metalness: 0.08,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        group.add(mesh);
      }

      return { group, triangleCount };
    }

    function parseWithOcct(occt, bytes) {
      const binaryParsed = occt.ReadStepFile(bytes, null);
      if (binaryParsed && binaryParsed.meshes && binaryParsed.meshes.length > 0) {
        return { parsed: binaryParsed, parser: 'occt-binary' };
      }

      const asText = decodeStepText(bytes);
      if (!asText) {
        throw new Error('parse-binary-failed');
      }

      const textBytes = new TextEncoder().encode(asText);
      const textParsed = occt.ReadStepFile(textBytes, null);
      if (textParsed && textParsed.meshes && textParsed.meshes.length > 0) {
        return { parsed: textParsed, parser: 'occt-text' };
      }

      throw new Error('parse-text-failed');
    }

    function parseStl(bytes) {
      const loader = new THREE.STLLoader();
      const geometry = loader.parse(bytes.buffer);
      if (!geometry) {
        throw new Error('parse-stl-failed');
      }

      const material = new THREE.MeshStandardMaterial({ color: new THREE.Color('#4a78bb'), roughness: 0.55, metalness: 0.08 });
      const mesh = new THREE.Mesh(geometry, material);
      const group = new THREE.Group();
      group.add(mesh);
      return { group, triangleCount: Math.max(0, Math.floor((geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3)), parser: 'three-stl' };
    }

    function parseObj(bytes) {
      const loader = new THREE.OBJLoader();
      const text = new TextDecoder('utf-8', { fatal: false }).decode(bytes);
      const group = loader.parse(text);
      let triangleCount = 0;

      group.traverse(node => {
        if (!node.isMesh || !node.geometry) {
          return;
        }

        node.material = new THREE.MeshStandardMaterial({ color: new THREE.Color('#4a78bb'), roughness: 0.55, metalness: 0.08, side: THREE.DoubleSide });
        if (node.geometry.index) {
          triangleCount += Math.floor(node.geometry.index.count / 3);
        } else if (node.geometry.attributes && node.geometry.attributes.position) {
          triangleCount += Math.floor(node.geometry.attributes.position.count / 3);
        }
      });

      return { group, triangleCount, parser: 'three-obj' };
    }

    function getOcctReaders(occt, fileType) {
      if (fileType === 'step') {
        return [occt.ReadStepFile].filter(Boolean);
      }

      if (fileType === 'iges') {
        return [occt.ReadIgesFile].filter(fn => typeof fn === 'function');
      }

      if (fileType === 'brep') {
        return [occt.ReadBrepFile].filter(fn => typeof fn === 'function');
      }

      if (fileType === 'sldprt') {
        return [occt.ReadStepFile, occt.ReadBrepFile, occt.ReadIgesFile].filter(fn => typeof fn === 'function');
      }

      return [];
    }

    function parseOcctWithReaders(bytes, readers) {
      for (const reader of readers) {
        try {
          const parsed = reader(bytes, null);
          if (parsed && parsed.meshes && parsed.meshes.length > 0) {
            return parsed;
          }
        } catch {
          // Try next parser strategy.
        }
      }

      return null;
    }

    function detectFileType(fileName) {
      const value = (fileName || '').toLowerCase();
      if (value.endsWith('.stl')) return 'stl';
      if (value.endsWith('.obj')) return 'obj';
      if (value.endsWith('.iges') || value.endsWith('.igs')) return 'iges';
      if (value.endsWith('.brep') || value.endsWith('.brp')) return 'brep';
      if (value.endsWith('.sldprt')) return 'sldprt';
      return 'step';
    }

    async function renderModelFromBase64(base64, metadata) {
      if (!base64 || base64.length === 0) {
        clearScene();
        return result(false, 'validate-bytes', 'missing-file-data');
      }

      try {
        const fileType = (metadata && metadata.fileType ? metadata.fileType : '').toLowerCase();

        const bytes = base64ToUint8Array(base64);
        let meshData;

        if (fileType === 'step') {
          const validation = validateStepContent(bytes);
          if (!validation.ok) {
            clearScene();
            return validation;
          }

          let occt;
          try {
            occt = await getOcctModule();
          } catch {
            clearScene();
            return result(false, 'js-parse', 'module-load-failed');
          }

          const parsedResult = parseWithOcct(occt, bytes);
          const occtMeshData = buildMeshGroup(parsedResult.parsed || {});
          meshData = { group: occtMeshData.group, triangleCount: occtMeshData.triangleCount, parser: parsedResult.parser };
        } else if (fileType === 'stl') {
          meshData = parseStl(bytes);
        } else if (fileType === 'obj') {
          meshData = parseObj(bytes);
        } else if (fileType === 'iges' || fileType === 'brep' || fileType === 'sldprt') {
          let occt;
          try {
            occt = await getOcctModule();
          } catch {
            clearScene();
            return result(false, 'js-parse', 'module-load-failed');
          }

          const readers = getOcctReaders(occt, fileType);
          if (!readers || readers.length === 0) {
            clearScene();
            return result(false, 'js-parse', 'parser-not-available');
          }

          const parsed = parseOcctWithReaders(bytes, readers);
          if (!parsed) {
            clearScene();
            return result(false, 'js-parse', fileType === 'sldprt' ? 'sldprt-not-supported' : 'corrupted-or-invalid-step');
          }

          const occtMeshData = buildMeshGroup(parsed || {});
          meshData = { group: occtMeshData.group, triangleCount: occtMeshData.triangleCount, parser: `occt-${fileType}` };
        } else {
          clearScene();
          return result(false, 'validate-bytes', 'unsupported-format');
        }

        if (meshData.group.children.length === 0) {
          clearScene();
          return result(false, 'render', 'empty-geometry', '', meshData.parser, meshData.group.children.length, meshData.triangleCount);
        }

        clearScene();
        activeMeshRoot = meshData.group;
        scene.add(activeMeshRoot);
        fitCameraToObject(activeMeshRoot);
        return {
          ok: true,
          stage: 'render',
          error: '',
          meshCount: meshData.group.children.length,
          triangleCount: meshData.triangleCount,
          parser: meshData.parser
        };
      } catch (err) {
        clearScene();
        const parseError = (err && err.message) ? err.message : 'corrupted-or-invalid-step';
        const parseStack = (err && err.stack) ? err.stack : '';
        return result(false, 'js-parse', parseError, parseStack);
      }
    }

    function resizeRenderer() {
      const width = Math.max(viewport.clientWidth, 1);
      const height = Math.max(viewport.clientHeight, 1);
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    function resetViewerState() {
      clearScene();
      renderer.renderLists.dispose();
      controls.reset();
    }

    function disposeViewer() {
      clearScene();
      renderer.renderLists.dispose();
      renderer.dispose();
      controls.dispose();
    }


    function runStepSelfTest() {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: new THREE.Color('#4a78bb'), roughness: 0.55, metalness: 0.08 });
      const mesh = new THREE.Mesh(geometry, material);
      const group = new THREE.Group();
      group.add(mesh);
      clearScene();
      activeMeshRoot = group;
      scene.add(activeMeshRoot);
      fitCameraToObject(activeMeshRoot);
      return { ok: true, stage: 'render', error: '', meshCount: 1, triangleCount: 12, parser: 'self-test-box' };
    }

    window.renderModelFromBase64 = renderModelFromBase64;
    window.runStepSelfTest = runStepSelfTest;
    window.resizeRenderer = resizeRenderer;
    window.resetViewerState = resetViewerState;
    window.disposeViewer = disposeViewer;

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    resizeRenderer();
    animate();
    window.addEventListener('resize', resizeRenderer);

    window.stepViewer = {
      isReady: () => window.__stepViewerReady === true,
      parseStepBase64: async (b64, fileName) => {
        try {
          const fileType = detectFileType(fileName);
          const value = await renderModelFromBase64(b64, { fileName: fileName || '', fileType });
          return {
            ok: !!value?.ok,
            meshes: value?.meshCount || 0,
            triangles: value?.triangleCount || 0,
            parser: value?.parser || '(none)',
            stage: value?.stage || 'js-parse',
            error: value?.error || '',
            stack: value?.stack || ''
          };
        } catch (err) {
          return {
            ok: false,
            meshes: 0,
            triangles: 0,
            parser: '(none)',
            stage: 'js-parse',
            error: String(err?.message || err || 'parse-failed'),
            stack: String(err?.stack || '')
          };
        }
      }
    };

    window.__stepViewerVersion = '1.0.0';
    window.__stepViewerReady = true;
    window.__stepViewerStatus.version = '1.0.0';
    window.__stepViewerStatus.phase = 'ready';
    window.__stepViewerStatus.ready = true;
  </script>
</body>
</html>
