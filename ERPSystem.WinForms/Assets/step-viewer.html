<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body, #viewport { margin:0; padding:0; width:100%; height:100%; background:#f8fafc; overflow:hidden; }
  </style>
</head>
<body>
  <div id="viewport"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    const viewport = document.getElementById('viewport');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#f8fafc');
    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 5000);
    camera.position.set(1.4, 1.2, 1.7);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    viewport.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;
    scene.add(new THREE.HemisphereLight(0xffffff, 0x6f7a88, 0.95));
    const keyLight = new THREE.DirectionalLight(0xffffff, 0.75);
    keyLight.position.set(3, 6, 5);
    scene.add(keyLight);

    let activeRoot = null;

    function resizeRenderer() {
      const width = Math.max(1, viewport.clientWidth || window.innerWidth || 1);
      const height = Math.max(1, viewport.clientHeight || window.innerHeight || 1);
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    function fitCameraToObject(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z, 0.001);
      const dist = maxDim * 2.2;
      controls.target.copy(center);
      camera.position.set(center.x + dist, center.y + dist * 0.7, center.z + dist);
      camera.near = Math.max(maxDim / 1000, 0.001);
      camera.far = Math.max(maxDim * 200, 500);
      camera.updateProjectionMatrix();
      controls.update();
    }

    function clearModel() {
      if (!activeRoot) return;
      scene.remove(activeRoot);
      activeRoot.traverse(node => {
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) node.material.forEach(m => m.dispose());
          else node.material.dispose();
        }
      });
      activeRoot = null;
    }

    function base64ToArrayBuffer(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    const loader = new THREE.GLTFLoader();
    window.renderGlbBase64 = async function(base64) {
      try {
        clearModel();
        const buffer = base64ToArrayBuffer(base64);
        const gltf = await loader.parseAsync(buffer, '');
        activeRoot = gltf.scene || gltf.scenes?.[0];
        if (!activeRoot) return false;
        scene.add(activeRoot);
        fitCameraToObject(activeRoot);
        resizeRenderer();
        return true;
      } catch (err) {
        console.error('GLB render failed', err);
        return false;
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', resizeRenderer);
    resizeRenderer();
    animate();
  </script>
</body>
</html>
